# Test file for mcmc on gtr model with primates dataset

# read the data
# the readCharacter function returns a vector of matrices. We just take the first one
D <- readCharacterData("data/Primates.nex")[1]

# get some useful variables from the data
taxaCount <- D.ntaxa()
nSites <- D.nchar()[1]
names <- D.names()

# Birth-Death process priors
diversification ~ exponential(0.1)
turnover ~ exponential(0.1)
org ~ unif(0,100.0)

mi <- 0
# moves for the birth-death paramaters
moves[mi++] <- mScale(diversification,lambda=1,tune=true,weight=1)
moves[mi++] <- mScale(turnover,lambda=1,tune=true,weight=1)
moves[mi++] <- mSlide(org,delta=1,tune=true,weight=1)

# tree from birth-death process
tau ~ cBDP(origin=org, diversification, turnover, nTaxa=taxaCount, names=names)

# moves on the tree
#moves[mi++] <- mNNI(tau, weight=1.0)
#moves[mi++] <- mFNPR(tau, weight=1.0)
#moves[mi++] <- mSubtreeScale(tau, weight=5.0)
moves[mi++] <- mTreeScale(tau, lambda=1.0, tune=true, weight=3.0)
moves[mi++] <- mNodeTimeSlideUniform(tau, weight=10.0)
moves[mi++] <- mRootTimeSlide(tau, delta=1.0, tune=true, weight=3.0)

# substition model priors
bf <- v(1,1,1,1)
e <- v(1,1,1,1,1,1)
pi ~ dirichlet(bf)
er ~ dirichlet(e)

# let's set some "reasonable" starting values
# first we look what we had
pi
er
# You could comment these out and see how the convergence of the MCMC is influenced by the starting values.
# Usually these starting values will lead to much faster convergence
pi.setValue( simplex(1,1,1,1) )
er.setValue( simplex(1,1,1,1,1,1) )
# now check the new values
pi
er

# moves on the substitution process parameters
# first some moves only changing one value of the simplex
moves[mi++] <- mSimplexElementScale(pi, alpha=10.0, tune=true, weight=4.0)
moves[mi++] <- mSimplexElementScale(er, alpha=10.0, tune=true, weight=6.0)

# the rate matrix
Q := gtr(er,pi)


##cr ~ dnGamma(2.0,4.0)
n_branches <- 2 * taxaCount - 2


for(i in 1:n_branches){
	branch_rates[i] ~ dnGamma(2.0,4.0)
	moves[mi++] <- mvScale(branch_rates[i],lambda=0.5,tune=true,weight=2.0)
}

mean_rt := mean(branch_rates)

# the sequence evolution model
seq ~ substModel(tree=tau, Q=Q, branchRates=branch_rates, nSites=nSites, type="DNA")

# attach the data
seq.clamp(D)

mymodel <- model(pi)

monitors[1] <- modelmonitor(filename="uncor_clock.log",printgen=10, separator = "	")
monitors[2] <- filemonitor(filename="uncor_clock.trees",printgen=10, separator = "	", tau)
monitors[3] <- screenmonitor(printgen=1, pi, branch_rates[1])

 
mymcmc <- mcmc(mymodel, monitors, moves)

# Note that one mcmc iteration includes 33 proposal (incl. accept/reject) which is the number of moves times their weight.
# If you choose more or different proposals, or different weights for the proposals, then the number of proposals changes per iteration.
#mymcmc.burnin(generations=1000,tuningInterval=100)
mymcmc.run(generations=2000)

