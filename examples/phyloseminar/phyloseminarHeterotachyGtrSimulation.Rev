
################
# That was too rough, let's use a mixture model that can account for heterotachy.
# We use a mixture model with two sets of branch lengths.
################


siteCount <- 100

nucleotides <- set(dna("A"),dna("C"),dna("G"),dna("T"))
pi <- simplex(1,2,3,4)
exchange <- simplex(1,1,1,1,1,1)



################
# Let's read in two trees,
# with identical topologies but widely different branch lengths
################
#Obviously the path will need to be changed for it to work on your computer...
tree1 <- readTrees("/Users/boussau/travail/revbayes/trunk/examples/phyloseminar/tree1.dnd")
tree2 <- readTrees("/Users/boussau/travail/revbayes/trunk/examples/phyloseminar/tree2.dnd")

#Tree with mock branch lengths, so that we get the topology right
tree <- readTrees("/Users/boussau/travail/revbayes/trunk/examples/phyloseminar/tree.dnd")


nodeCount <- tree1.nnodes()

num_setbl <- 2

#Prior for the rates
lambda_rate_prior <- 1.0

#Draw rate for each cluster of sites 

for (i in 1: (nodeCount - 1) ) {  
bls[1][i] <- tree1.getVariable("branchLength", tree1.node(i))
bls[2][i] <- tree2.getVariable("branchLength", tree2.node(i))
}

classprobas <- simplex(1,1)

#The Mixture simplest constructor creates the allocation vector and the probability vector (probabilityVector) and links them to the parameter vector into a coherent DAG on which computations can be performed.
blMixture <- mixture( numObservations=siteCount * nodeCount, parameters=bls , classProbabilities=classprobas)

for (i in nodeCount:1) {
node <- tree.node(i)
if (node.isRoot()) {   
for (j in 1:siteCount) {
dna_state[i][j] ~ cat(pi,nucleotides)
}
} else {
parent <- node.ancestor()
parentIndex[i] <- tree.index(parent)	
# create the rate matrix for this node
Q[i] := gtr(rates=exchange, freqs=pi)
#We generate the 2 substitution matrices corresponding to the two branch lengths
tp[1][i] := ctmmtp(Q[i],bls[1][i])
tp[2][i] := ctmmtp(Q[i],bls[2][i])
if (node.isTip()) {
for (j in 1:siteCount) {
numParam <- (i-1)*siteCount + j
if (blMixture.getElementAllocation(numParam) == 0 ) {
dna_state[i][j] ~ dtmm(tp[1][i] , dna_state[parentIndex[i]][j])
} else {
dna_state[i][j] ~ dtmm(tp[2][i] ,  dna_state[parentIndex[i]][j])
}
clamp(dna_state[i][j], D[i][j])
}
taxon[i] := taxonData(node.getName(), dna_state[i][1], dna_state[i][2], dna_state[i][3], dna_state[i][4], dna_state[i][5] )
}  else {
for (j in 1:siteCount) {
numParam <- (i-1)*siteCount + j
if (blMixture.getElementAllocation(numParam) == 0 ) {
dna_state[i][j] ~ dtmm(tp[1][i] , dna_state[parentIndex[i]][j])
} else {
dna_state[i][j] ~ dtmm(tp[2][i] , dna_state[parentIndex[i]][j])
}
}
}	
}
}

###BUG HERE

mygtrheterotachy <- model( tree.node(1) )


################
# Now we have a simple GTR+mixture model on a tree with 5 leaves.
# Let's simulate nsites sites
################

#Where we want to put the simulated alignment:
objectMonitors <- objectMonitor(printgen=1, mu, e, sigma, x)
filemonitors <- fileMonitor(filename="gtrSimulation.out", printgen=1, separator="	", mu, e, sigma, x)

mysimu <- simulate(mygtrheterotachy, filemonitors, objectMonitors)
mysimu.run(1)



mons <- mysimu.getMonitors()
for (i in 1:tau.nTips()) {
t[i] <- mons[1].getValues("taxon[" + i + "]")[1]
}
D <- characterData("dna", t[1], t[2], t[3], t[4], t[5])



################
# Now we can do some inference!
################
##We need to define moves
numMoves <- 0

#Move on the stationary frequencies and rates
moves[numMoves+1] <- msimplex(4)
moves[numMoves+2] <- msimplex(6)

#Moves on the mixture
numMoves <- size(moves)

#Move on the rate parameters of the mixture
for (j in 1:  size(bl) ) {  
moves[numMoves+j] <- mscale(rate_parameters[j], weight=1.0, lambda = 1.0)
}

numMoves <- size(moves)
moves[numMoves+1]<-changeClassProbabilitiesMove(rateMixture)

numMoves <- size(moves)
for (i in 1:rateMixture.getNumberOfElements() ) {
moves[i + numMoves] <- reallocate(rateMixture, i)
}

numMoves <- size(moves)
for (i in 1:rateMixture.getNumberOfClasses() ) {
moves[i + numMoves] <- mscale(rateMixture.getParameter(i), weight=1.0, lambda = 1.0)
}


mymcmcgtrheterotachy <- mcmc(mygtrheterotachy, moves=moves, monitor=filemonitors)

mymcmcgtrheterotachy.run(generations=1000)

