# Series of phylogenetic models with and without mixtures to account for rate heterogeneity among sites. 

# By Bastien Boussau, Tracy Heath and Sebastian Hoehna



#####################
# Now we have the datat
# Let's do some inference
#####################

D <- read("data/primates_short.nex")

taxaCount <- D.ntaxa()
names <- D.names()

tau ~ unifTopology( numberTaxa=taxaCount, tipNames=names, isRooted=false, isBinary=true )

# Create the tree plate that is ordered by the topology
tree <- treeplate(tau)

siteCount <- D.nchar()[1]

nucleotides <- set(dna("A"),dna("C"),dna("G"),dna("T"))
pi <- simplex(1,2,3,4)
exchange <- simplex(1,1,1,1,1,1)

lambda <- 1.0
nodeCount <- tree.nnodes()

# We need to iterate from the root to the parent. The indices of the nodes are in phylogenetic ordering, i.e. the tip are at 1,É,n.
for (i in nodeCount:1) {
    node <- tree.node(i)
    if (node.isRoot()) {   
        for (j in 1:siteCount) {
            dna_state[i][j] ~ cat(pi,nucleotides)
            sumOver(dna_state[i][j], TRUE)
        }
    } else {
        parent <- node.ancestor()
        parentIndex[i] <- tree.index(parent)	

# here the prior for branch lengths
        bl[i] ~ exponential(lambda)
# adding this variable to the tree, so that we can easily access it later ...
        tree.addVariable("branchLength", bl[i], node)

# create the rate matrix for this node
        Q[i] := gtr(rates=exchange, freqs=pi)
# create the transition probability matrix for this node
        tp[i] := ctmmtp(Q[i],bl[i])
        if (node.isTip()) {
            for (j in 1:siteCount) {
                dna_state[i][j] ~ dtmm(tp[i], dna_state[parentIndex[i]][j])
                clamp(dna_state[i][j], D[i][j])
            }
        } else {
            for (j in 1:siteCount) {
                dna_state[i][j] ~ dtmm(tp[i], dna_state[parentIndex[i]][j])
                sumOver(dna_state[i][j], TRUE)
            }
        }	
    }
}


mygtr <- model( pi )

################
# Now we can do some inference!
################
##We need to define moves
#Moves on branch lengths
lambda <- 1.0
for (i in tree.nnodes():1) {
node <- tree.node(i)
if (! node.isRoot()) {
moves[i] <- mscale(bl[i], weight=1.0, lambda = 1.0)
}
}


#numMoves <- size(moves)


#Moves on the stationary frequencies and rates (in this model the
#rates and stationary frequencies are fixed!)
#moves[numMoves+1] <- msimplex(pi,4)
#moves[numMoves+2] <- msimplex(rates,6)

monitors[1] <- fileMonitor(filename="gtrSimulation.out", printgen=1, separator="	", bl)

mymcmcgtr <- mcmc(mygtr, moves=moves, monitor=monitors)

mymcmcgtr.run(generations=1000)

