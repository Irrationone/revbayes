# Series of phylogenetic models with and without mixtures to account for rate heterogeneity among sites. 

# By Bastien Boussau, Tracy Heath and Sebastian Hoehna

#################
# First we construct the tree topology with 5 taxa (we could also read it from a file)
#################
taxaCount <- 5
names <- ["A", "B", "C", "D", "E"]

tau ~ unifTopology( numberTaxa=taxaCount, tipNames=names, isRooted=false, isBinary=true )

# Create the tree plate that is ordered by the topology
tree <- treeplate(tau)

# or
# tree <- readTrees("trees/phyloseminar.trees")

#################
# First a simple GTR model without heterogeneity
#################
# Here we can specify the model by using the tree functions for generating node or branch
# indices. In rooted trees, T.node(i) would simply give the node at the index with respect
# to the root. node.ancestor() returns the parent of the node. Note, internally also unrooted trees 
# are rooted at an arbitrary node and therefore have a direction (parent <-> child relationship).

siteCount <- 100

nucleotides <- set(dna("A"),dna("C"),dna("G"),dna("T"))
pi <- simplex(1,2,3,4)
exchange <- simplex(1,1,1,1,1,1)

lambda <- 1.0
nodeCount <- tree.nnodes()

# We need to iterate from the root to the parent. The indices of the nodes are in phylogenetic ordering, i.e. the tip are at 1,É,n.
for (i in nodeCount:1) {
    node <- tree.node(i)
    if (node.isRoot()) {   
        for (j in 1:siteCount) {
            dna_state[i][j] ~ cat(pi,nucleotides)
        }
    } else {
        parent <- node.ancestor()
        parentIndex[i] <- tree.index(parent)	

# here the prior for branch lengths
        bl[i] ~ exponential(lambda)
# adding this variable to the tree, so that we can easily access it later ...
        tree.addVariable("branchLength", bl[i], node)

# create the rate matrix for this node
        Q[i] := gtr(rates=exchange, freqs=pi)
# create the transition probability matrix for this node
        tp[i] := ctmmtp(Q[i],bl[i])
        if (node.isTip()) {
            for (j in 1:siteCount) {
                dna_state[i][j] ~ dtmm(tp[i], dna_state[parentIndex[i]][j])
#                clamp(dna_state[i][j], D[i][j])
            }
            taxon[i] := taxonData(node.getName(), dna_state[i][1], dna_state[i][2], dna_state[i][3], dna_state[i][4], dna_state[i][5] )
        } else {
            for (j in 1:siteCount) {
                dna_state[i][j] ~ dtmm(tp[i], dna_state[parentIndex[i]][j])
            }
        }	
    }
}

mygtr <- model( pi )

################
# Now we have a simple GTR model on a tree with 5 leaves.
# Let's simulate nsites sites
################

#Where we want to put the simulated alignment:
monitors[1] <- objectMonitor(printgen=1, taxon)
monitors[2] <- fileMonitor(filename="gtrSimulation.out", printgen=1, separator="	", taxon)

mysimu <- simulate(mygtr, monitors)
mysimu.run(10)


monis <- mysimu.getMonitors()
gene <- monis[1].getValues("taxon[1]")
