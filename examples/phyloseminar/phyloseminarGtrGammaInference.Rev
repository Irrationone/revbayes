# Series of phylogenetic models with and without mixtures to account for rate heterogeneity among sites. 

# By Bastien Boussau, Tracy Heath and Sebastian Hoehna

#####################
# Now we have the datat
# Let's do some inference
#####################

D <- read("/Users/tracyh/Code/RevBayes_proj/revbayes/trunk/examples/data/primates_short.nex")

taxaCount <- D.ntaxa()
names <- D.names()

tau ~ unifTopology( numberTaxa=taxaCount, tipNames=names, isRooted=false, isBinary=true )
tree <- treeplate(tau)
nodeCount <- tree.nnodes()

siteCount <- D.nchar()[1]

nucleotides <- set(dna("A"),dna("C"),dna("G"),dna("T"))

pi_prior <- v(1,1,1,1)
pi ~ dirichlet(pi_prior)

r_prior <- v(1,1,1,1,1,1)
r ~ dirichlet(r_prior)

num_gamma_rates <- 4
alpha_prior <- 1.0
alpha ~ exponential (alpha_prior)

for ( i in 1:num_gamma_rates ){
	gamma_cat_ps[i] <- (1.0 / num_gamma_rates) * 0.5
	if( i > 1 ){
		gamma_cat_ps[i]<- (1.0 / num_gamma_rates) + gamma_cat_ps[i-1]
	}
	rate_parameters[i] := qgamma(gamma_cat_ps[i],alpha,alpha)
}
class_probabilities<-simplex(num_gamma_rates)



## Looking for a constructer that allows you to set the class probabilities
rateMixture <- mixture( numObservations=siteCount, parameters=rate_parameters, classProbabilities=class_probabilities)


# We need to iterate from the root to the parent. The indices of the nodes are in phylogenetic ordering, i.e. the tip are at 1,ƒ,n.
for (i in nodeCount:1) {
    node <- tree.node(i)
    if (node.isRoot()) {   
        for (j in 1:siteCount) {
            dna_state[i][j] ~ cat(pi,nucleotides)
            sumOver(dna_state[i][j], TRUE)
        }
    } else {
        parent <- node.ancestor()
        parentIndex[i] <- tree.index(parent)	

		# here the prior for branch lengths
        bl[i] ~ exponential(lambda)
		# adding this variable to the tree, so that we can easily access it later ...
        tree.addVariable("branchLength", bl[i], node)

		# create the rate matrix for this node
        Q[i] := gtr(rates=r, freqs=pi)
		# create the transition probability matrix for this node
        if (node.isTip()) {
            for (j in 1:siteCount) {
				### Right now, this doesn't work because getParameterForElem() has to return
				### a complex object and this gives an error because it won't multiply
				### the _mul function might have some issue with the type, even though 
				### rateMixture.getParameterForElem(j) returns a Real
				tp[i][j] := ctmmtp(Q[i],bl[i] * rateMixture.getParameterForElem(j))
                dna_state[i][j] ~ dtmm(tp[i][j], dna_state[parentIndex[i]][j])
                clamp(dna_state[i][j], D[i][j])
            }
        } else {
            for (j in 1:siteCount) {
				tp[i][j] := ctmmtp(Q[i],bl[i] * rateMixture.getParameterForElem(j))
                dna_state[i][j] ~ dtmm(tp[i][j], dna_state[parentIndex[i]][j])
                sumOver(dna_state[i][j], TRUE)
            }
        }	
    }
}


mygtrgamm <- model( pi )

################
# Now we can do some inference!
################
##We need to define moves
#Moves on branch lengths
lambda <- 1.0
for (i in tree.nnodes():1) {
	node <- tree.node(i)
	if (! node.isRoot()) {
		moves[i] <- mscale(bl[i], weight=1.0, lambda = 1.0)
	}
}

numMoves <- moves.size()

j <- numMoves+1
moves[j] <- msimplex(variable=pi,tuning=2.0,num_cats=4)
moves[j+1] <- msimplex(variable=r,tuning=2.0,num_cats=6)
moves[j+2] <- mscale(alpha, weight=1.0, lambda = 1.0)
numMoves <- moves.size()
for (i in 1:siteCount ) {
	moves[i + numMoves] <- reallocate(rateMixture, i)
}


monitors[1] <- fileMonitor(filename="gtrGammaInference.out", printgen=1, separator="	", bl)

mymcmcgtrgamm <- mcmc(mygtrgamm, moves=moves, monitor=monitors)

mymcmcgtrgamm.run(generations=1000)

