# Phylogenetic model test

# Read data from Nexus file
# Return type is data set (Dataset) or something similar
# Related functions, like readfasta and readphylip
# read these formats; I like this solution better than
# a generic command where you give format options, but
# we could implement both, that is, 
# readnexus("filename") could be the same as readdata("filename", format="nexus")
# For now, I think one data type for data sets is sufficient, it could have a
# member method for querying the character data type ("DNA", "RNA", etc )

D <- readnexus("data.nex")

# Create a sequence of the right length and data type
# Return type of dnasequence is DNASequence, which is the same as DNA[] in terms of language type

S <- dnasequence( D.numchars() )

# Alternatively, we could just have gotten one of the sequences in the data matrix. It is important
# though that we create a new object for use as the template when we create the tree plate. In the
# second solution, it does not matter that we get a sequence associated with S, it will just be
# treated as a current value when S is transferred to a stochastic node later.
#
# S <- D[1]

# Create branch length parameter

b ~ exp(10)
# @Fredrk: Why is 'b' not a vector? (Sebastian)

# Create topology parameter
#
# If you create it from the data set, as below, I assume you will get the topology
# filled with taxon names and tree size automatically. I further assume the default
# will be to create a dichotomous topology, and then we will have a
# flag in the topology data type for whether it is polytomous, or we
# implement different topology data types for polytomous trees (my
# guess is that the latter approach might work better in the long run, since we
# might want to distinguish between polytomous and dichotomous topologies in
# many contexts, for instance in deciding on the acceptable types for functions).

tau ~ utopologyunif( D)

# Some discussion about topology and clock tree data types is warranted.
#
# I prefer to have three different classes: unrooted topology, rooted topology,
# and clock tree. I know that John is keen on treating clock trees simply
# as a collection of a rooted topology and a node time vector. 
#
# Sebastian: I agree, different implementation might be beneficiary.
#
# Both solutions work but I did spend a little time thinking about the different
# strategies and my very preliminary conclusion is that we probably would
# be more happy with the integrated clock tree approach in the long run.
# Here are some of the reasons for and against:
#
# If clock trees are composite objects (topology plus node times), we will end
# up with more complicated ways of linking the time parameter to the topology
# for clock models. For instance, with the integrated solution, we could easily
# implement the birth-death distribution as being on clock trees, that
# is (tau is type Clock-tree):
#
# tau ~ birthdeath(<parameters>)
#
# With the composite solution, one would have to implement the birth-death
# model as a stochastic process with several different distributions associated
# with it. The same model would then look like (tau is now type RootedTopology):
# 
# tau    ~ birthdeath(<parameters>).getTopologyDistribution()
# Tree.t ~ birthdeath(<parameters>).getNodetimeDistribution()
#
# where Tree.t is the tree plate parameter assigned by the user to be
# the node time vector.
#
# Treating clock-tree as an integrated data type would give us a 
# natural place to store and give out the time parameter for various
# models that would like to create functions of or distributions based
# on the time parameter. The tree plate would simply query the clock tree
# when giving out the node time vector, or tying things to the tree clock.
# If we treated clock trees as composite objects instead, the tree plate
# functions that gave out the same things would require
# more complex checking by the tree plate code to make sure it understood
# which one of the plate parameters was the designated time parameter.
#
# If it makes sense to think about one and the same topology being associated
# with several different node time vectors, the integrated approach would still
# allow one to use the composite approach as an alternative. However, I did spend
# some time thinking about this when programming clock models in MrBayes, and I
# could not come up with a single case where such a model would make sense. So,
# in 99 % of the cases, I would think, we are dealing with models where it is natural
# to consider the node times and topology as one integrated unit in the clock tree models.
# If we had to treat all these models using the composite approach, the user could
# easily create problems inadvertently by not keeping track of which of the tree
# plate parameters they used as the node time vector. At the same time, the integrated
# approach would be perfectly consistent with also allowing users to specify clock tree
# models using the composite representation.
#
# Treating clock-tree as an integrated data type would make it quite easy
# to formulate gene tree - species tree models where the folding of one into the
# other involves the node times. For instance,
#
# S ~ birthdeath(<params>
# G[i] ~ speciestree_coalescent(S, <coalescentparams>)  # in a loop over gene tree partitions
#
# with S and G[i] being of type clock tree, would be a natural way of specifying such
# models. The gene tree plates would then be set up as usual, using each of the G[i]
# elements of the G vector. Using the composite approach, one would have to add the
# extra node time vector in a rather unnatural way into this scheme, something like
#
# Stop  ~ birthdeath(<params>).topologyDistr()
# +Real t
# Stree <- tree(Stop, t)
# Stree.t ~ birthdeath(<params>).nodetimeDistr()
#   [-- making sure it is the same process params used for the topology, I assume]
# Gtop[i] ~ speciestree_coalescent(Stop, Stree.t, <coalescentparams>).topologyDistr()
# Gtree[i] <- tree(Stop, t)
# Gtree[i].t ~ speciestree_coalescent(Stop, Stree.t, <coalescentparams>).nodetimeDistr()
#
# It will be interesting to hear your ideas concerning this.


# Create tree
#
# The first parameter is the topology, the following one are template parameters used
# to populate the tree plate.

T <- tree(tau, S, t)
# @Fredrik: 't' was never created before (or after). (Sebastian)

# Now we can specify the model by using the tree functions for generating node or branch
# indices. In clock trees, T.anc(i) would simply give the ancestral node index with respect
# to the arbitrarily placed calculation root (which would be a node with degree three, I
# assume, all thre being descendants in this case).

pi ~ dirich(4)
r ~ dirich(6)
Q <- gtr_ratematrix(pi, r)
# @Fredrik: shouldn't Q be a deterministic node? (Sebastian)

for (i in T.nodes())
    T.S[i] ~ ctmc(T.S[ T.anc(i) ], Q, T.b[i])
    
for (i in T.tips())
    clamp(T.S[i], D[i])

S[T.calcroot()] ~ Q.stationaryDistr()

# Alternatively, thinking about a ctmc as a more complex stochastic process object giving
# out distributions, one would instead use something like

CTMC <- ctmc(Q)

for (i in 1:T.nodes()) {
    T.S[i] ~ CTMC.transitionProbDistr(T.S[ T.anc(i) ], T.b[i])
}    
# @Fredrik: What should T.anc(i) return if T.node(i) is the root node? (Sebastian)

for (i in T.tips()) {
    clamp(T.S[i], D[i])
}

S[T.calcroot()] ~ CTMC.stationaryDistr()

# Note that in these examples I assume that the ctmc or CTMC.transitionProbDistr()
# functions are overloaded to allow you to specify distributions with sequence parameters on
# sequence random variables, assuming matching iid indices for both. If we do not allow this
# one would have to explicitly loop over the sites also, like this for the first example:

for ( i in 1:T.nodes() )
    for ( j in 1:T.S[1].size() )
        T.S[i][j] ~ ctmc(T.S[ T.anc(i) ][j], Q, T.b[i])
    
