# Series of phylogenetic models with and without mixtures to account for rate heterogeneity among sites. 

# By Bastien Boussau, Tracy Heath and Sebastian Hoehna

#################
# First we construct the tree topology with 5 taxa (we could also read it from a file)
#################
taxaCount <- 5
names <- ["A", "B", "C", "D", "E"]

tau ~ unifTopology( numberTaxa=taxaCount, tipNames=names, isRooted=false, isBinary=true )

# Create the tree plate that is ordered by the topology
tree <- treeplate(tau)

# or
# tree <- readTrees("trees/phyloseminar.trees")

#################
# First a simple GTR model without heterogeneity
#################
# Here we can specify the model by using the tree functions for generating node or branch
# indices. In rooted trees, T.node(i) would simply give the node at the index with respect
# to the root. node.ancestor() returns the parent of the node. Note, internally also unrooted trees 
# are rooted at an arbitrary node and therefore have a direction (parent <-> child relationship).

print(filename = "", append = FALSE, "Setting up the model for simulation.")

siteCount <- 1000

nucleotides <- set(dna("A"),dna("C"),dna("G"),dna("T"))
pi <- simplex(1,2,3,4)
exchange <- simplex(1,1,1,1,1,1)

# here the prior for branch lengths
bl <- v(0.01,0.01,0.01,0.01,0.01,0.05,0.05,0.05,0.10)

lambda <- 1.0
nodeCount <- tree.nnodes()


#Where we want to put the simulated alignment:
monitors[1] <- objectMonitor(printgen=1)
monitors[2] <- fileMonitor(filename="gtrSimulation.out", printgen=1, separator="	")

# We need to iterate from the root to the parent. The indices of the nodes are in phylogenetic ordering, i.e. the tip are at 1,...,n.
for (i in nodeCount:1) {
    node <- tree.node(i)
    if (node.isRoot()) {   
        for (j in 1:siteCount) {
            dna_state[i][j] ~ cat(pi,nucleotides)
        }
    } else {
        parent <- node.ancestor()
        parentIndex[i] <- tree.index(parent)	

# adding this variable to the tree, so that we can easily access it later ...
        tree.addVariable("branchLength", bl[i], node)

# create the rate matrix for this node
        Q[i] := gtr(rates=exchange, freqs=pi)
# create the transition probability matrix for this node
        tp[i] := ctmmtp(Q[i],bl[i])
        if (node.isTip()) {
            for (j in 1:siteCount) {
                dna_state[i][j] ~ dtmm(tp[i], dna_state[parentIndex[i]][j])
#                clamp(dna_state[i][j], D[i][j])
            }
#            taxon[i] := taxonData(node.getName(), dna_state[i][1], dna_state[i][2], dna_state[i][3], dna_state[i][4], dna_state[i][5] )
            taxon[i] := taxonData(node.getName(), dna_state[i] )
            taxon[i].addMonitor(monitors[1])
            taxon[i].addMonitor(monitors[2])
        } else {
            for (j in 1:siteCount) {
                dna_state[i][j] ~ dtmm(tp[i], dna_state[parentIndex[i]][j])
            }
        }	
    }
}

mygtr <- model( pi, taxon )

################
# Now we have a simple GTR model on a tree with 5 leaves.
# Let's simulate nsites sites
################

print(filename = "", append = FALSE, "Simulate under our GTR model.")

mysimu <- simulate(mygtr)
mysimu.run(1)


mons <- mysimu.getMonitors()
for (i in 1:tau.nTips()) {
   t[i] <- mons[1].getValues("taxon[" + i + "]")[1]
}
D <- characterData("dna", t[1], t[2], t[3], t[4], t[5])


#####################
# Now we have the datat
# Let's do some inference
#####################

taxaCount <- D.ntaxa()
names <- D.names()

#tau ~ unifTopology( numberTaxa=taxaCount, tipNames=names, isRooted=false, isBinary=true )

# Create the tree plate that is ordered by the topology
#tree <- treeplate(tau)

siteCount <- D.nchar()[1]

print(filename = "", append = FALSE, "Setting up the model for inference.")

nucs <- set(dna("A"),dna("C"),dna("G"),dna("T"))

pi_prior <- v(1,1,1,1)
pi_inference ~ dirichlet(pi_prior)
#pi_inference <- simplex(1,5,1,10)

r_prior <- v(1,1,1,1,1,1)
r_inference ~ dirichlet(r_prior)
#r_inference <- simplex(1,1,1,1,1,1)

lambda <- 1.0
nodeCount <- tree.nnodes()

        Q_inference := gtr(rates=r_inference, freqs=pi_inference)
# We need to iterate from the root to the parent. The indices of the nodes are in phylogenetic ordering, i.e. the tip are at 1,...,n.
for (i in nodeCount:1) {
    node <- tree.node(i)
    if (node.isRoot()) {   
        for (j in 1:siteCount) {
            dna_state_inference[i][j] ~ cat(pi_inference,nucs)
            sumOver(dna_state_inference[i][j], TRUE)
        }
    } else {
        parent <- node.ancestor()
        parentIndex[i] <- tree.index(parent)	

# here the prior for branch lengths
        bl_inference[i] ~ exponential(lambda)
# adding this variable to the tree, so that we can easily access it later ...
#        tree.addVariable("branchLength", bl[i], node)

# create the rate matrix for this node
# create the transition probability matrix for this node
        tp_inference[i] := ctmmtp(Q_inference,bl_inference[i])
        if (node.isTip()) {
            for (j in 1:siteCount) {
                dna_state_inference[i][j] ~ dtmm(tp_inference[i], dna_state_inference[parentIndex[i]][j])
                clamp(dna_state_inference[i][j], D[i][j])
            }
        } else {
            for (j in 1:siteCount) {
                dna_state_inference[i][j] ~ dtmm(tp_inference[i], dna_state_inference[parentIndex[i]][j])
                sumOver(dna_state_inference[i][j], TRUE)
            }
        }	
    }
}

################
# Now we can do some inference!
################
##We need to define moves
#Moves on branch lengths
for (i in tree.nnodes():1) {
   node <- tree.node(i)
   if (! node.isRoot()) {
      moves[i] <- mscale(weight=1.0, lambda = 1.0)
      bl_inference[i].addMove(moves[i])
   }
}


numMoves <- moves.size()

j <- numMoves+1
moves[j] <- msimplex(tuning=50.0,num_cats=4)
pi_inference.addMove(moves[j])
moves[j+1] <- msimplex(tuning=25.0,num_cats=6)
r_inference.addMove(moves[j+1])

monis[1] <- fileMonitor(filename="gtrInference.out", printgen=1,
separator="	")
pi_inference.addMonitor(monis[1])
r_inference.addMonitor(monis[1])
monis[2] <- objectMonitor(printgen=1)
for (i in 1:bl_inference.size()) {
   bl_inference[i].addMonitor(monis[1])
   bl_inference[i].addMonitor(monis[2])
}

mygtrinf <- model( pi_inference, bl_inference )

mymcmcgtr <- mcmc(mygtrinf)

mymcmcgtr.run(generations=1000)

mons <- mymcmcgtr.getMonitors()
for (i in 1:(tree.nnodes()-1) ) {
   branchL[i] <- mons[2].getValues("bl_inference[" + i + "]")
   mean(branchL[i])
}
