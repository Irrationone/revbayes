# Series of phylogenetic models with and without mixtures to account for rate heterogeneity among sites. 

# By Bastien Boussau, Tracy Heath and Sebastian Hoehna

# Chi Zhang modified phyloseminarGtrInference.Rev

#####################
# Now we have the data
# Let's do some inference
#####################

D <- read("/Users/chi/Dropbox/RevBayes/trunk/examples/data/primates_short.nex")

taxaCount <- D.ntaxa()
names <- D.names()

tau ~ unifTopology( numberTaxa=taxaCount, tipNames=names, isRooted=false, isBinary=true )

# Create the tree plate that is ordered by the topology
tree <- treeplate(tau)

siteCount <- D.nchar()[1]

nucleotides <- set(dna("A"),dna("C"),dna("G"),dna("T"))

pi_prior <- v(1,1,1,1)
pi ~ dirichlet(pi_prior)

r_prior <- v(1,1,1,1,1,1)
r ~ dirichlet(r_prior)

# lambda <- 1.0
nodeCount <- tree.nnodes()

#######
# for the compound Dirichlet prior

alpha_T <- 1.0
 beta_T <- 1.0
TreeL ~ gamma(alpha_T, beta_T)
a_prior <- rep(1, nodeCount) 
# parameter for the Dirichlet distribution, depending on number of taxa
# a_prior <- v(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
part ~ dirichlet(a_prior)

########

# We need to iterate from the root to the parent. The indices of the nodes are in phylogenetic ordering, i.e. the tip are at 1,Ã‰,n.
for (i in nodeCount:1) {
    node <- tree.node(i)
    if (node.isRoot()) {   
        for (j in 1:siteCount) {
            dna_state[i][j] ~ cat(pi,nucleotides)
            sumOver(dna_state[i][j], TRUE)
        }
    } else {
        parent <- node.ancestor()
        parentIndex[i] <- tree.index(parent)	

# here the prior for branch lengths
#        bl[i] ~ exponential(lambda)
        bl[i] := TreeL * part[i]

# adding this variable to the tree, so that we can easily access it later ...
        tree.addVariable("branchLength", bl[i], node)

# create the rate matrix for this node
        Q[i] := gtr(rates=r, freqs=pi)
# create the transition probability matrix for this node
        tp[i] := ctmmtp(Q[i],bl[i])
        if (node.isTip()) {
            for (j in 1:siteCount) {
                dna_state[i][j] ~ dtmm(tp[i], dna_state[parentIndex[i]][j])
                clamp(dna_state[i][j], D[i][j])
            }
        } else {
            for (j in 1:siteCount) {
                dna_state[i][j] ~ dtmm(tp[i], dna_state[parentIndex[i]][j])
                sumOver(dna_state[i][j], TRUE)
            }
        }	
    }
}


mygtr <- model( pi )

################
# Now we can do some inference!
################
##We need to define moves
#Moves on branch lengths
lambda <- 1.0
for (i in tree.nnodes():1) {
    node <- tree.node(i)
    if (! node.isRoot()) {
        moves[i] <- mscale(bl[i], weight=1.0, lambda = 1.0)
    }
}


numMoves <- moves.size()

j <- numMoves+1
moves[j] <- msimplex(variable=pi,tuning=2.0,num_cats=4)
moves[j+1] <- msimplex(variable=r,tuning=2.0,num_cats=6)

monitors[1] <- fileMonitor(filename="gtrSimulation.out", printgen=1, separator="	", bl)

mymcmcgtr <- mcmc(mygtr, moves=moves, monitor=monitors)

mymcmcgtr.run(generations=1000)


