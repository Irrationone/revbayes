#
# Tutorial -- the phylogenetic comparative method
# Correlation analysis of life-history traits in placental mammals
# taking into account uncertainty about divergence times
# Nicolas Lartillot -- July 2014
#

######### 
# data
#########

# read the trait data 
contData <- readCharacterData("data/plac40lhtlog.nex")

# output a brief summary
contData

# get some useful variables from the data
taxaCount <- contData.ntaxa()
names <- contData.names()
nTraits <- contData.nchar()[1]

"number of traits to analyze"
nTraits

# read the sequence data
seqData <- readCharacterData("data/plac40_4fold.nex")
nSites <- seqData.nchar()[1]
"number of sites of the alignment"
nSites

######### 
# tree  
#########

# create a tree whose tips match the taxon names given by the dataset
tau ~ uniformTimeTree( originTime = 1.0, taxonNames = names)

# work under fixed topology
# set tau equal to externally given tree
treeArray <- readTrees("data/chronoplac40.tree")
fixedTree <- treeArray[1]
tau.setValue(fixedTree)

# moves on divergence times (only relative dating: no fossils here)
index <- 1
moves[index] <- mSubtreeScale(tau, weight=5.0)
index <- index + 1
moves[index] <- mNodeTimeSlideUniform(tau, weight=10.0)
index <- index + 1

# if we wanted to, we could also move the tree topology
# and integrate over the posterior induced by the sequence data
# but mixing is currently a bit challenging 
# moves[index] <- mNNI(tau, weight=5.0)
# index <- index + 1
# moves[index] <- mFNPR(tau, weight=5.0)
# index <- index + 1

######### 
# traits
#########

# covariance matrix Sigma (of dimension nTraits)
# InverseWishart of parameter Sigma_0 = kappa * I_nTraits, and df=nTraits+2 degrees of freedom
# where kappa is itself a scale parameter

kappa ~ exponential(1.0)
df <- nTraits+2
Sigma ~ invWishart(dim=nTraits, kappa=kappa, df=df)

# multivariate Brownian process along the tree
# parameterized by Sigma
X ~ mvtBrownian(tau,Sigma)

# moves on kappa
index <- 1
moves[index] <- mScale(kappa, lambda=2.0, tune=true, weight=3.0)
index <- index + 1

# conjugate Gibbs move on covariance matrix
moves[index] <- mvConjugateInverseWishartBrownian(sigma=Sigma, process=X, kappa=kappa, df=df, weight=1) 
index <- index + 1

# moves on the Brownian process
moves[index] <- mvMultivariatePhyloProcessSliding(process=X,lambda=1,tune=true,weight=100) 
index <- index + 1
moves[index] <- mvMultivariatePhyloProcessTranslation(process=X,lambda=0.1,tune=true,weight=1) 
index <- index + 1

# condition Brownian model on quantitative trait data
# i.e. clamp the process at the tips of the tree, ot the values observed in extant taxa
# you need to do this trait by trait
for (i in 1:nTraits)	{
	# here we say that the ith entry of the Brownian process should map to the ith. quantitative trait
	X.clampAt(contData,i,i)
}

# get useful functions of the covariance matrix, to be monitored
for (i in 1:nTraits)	{
	var[i] := Sigma.covariance(i,i)
}

k <- 1;
for (i in 1:(nTraits-1))	{
	for (j in (i+1):nTraits)	{
		correl[k] := Sigma.correlation(i,j)
		pCorrel[k] := Sigma.partialCorrelation(i,j)
		k <- k+1
	}
}

# get useful outputs from the brownian process
# the mean and the variance across the tree, for each trait
for (i in 1:nTraits)	{
	meanX[i] := X.mean(i)
	stdevX[i] := X.stdev(i)
}


######### 
# substitution process
#########

# equilibrium frequencies 
bf <- v(1,1,1,1)
pi ~ dirichlet(bf)

# exchangeabilities
e <- v(1,1,1,1,1,1)
er ~ dirichlet(e)

# moves on the substitution process parameters
moves[index] <- mSimplexElementScale(pi, alpha=10.0, tune=true, weight=1.0)
index <- index + 1
moves[index] <- mSimplexElementScale(er, alpha=10.0, tune=true, weight=1.0)
index <- index + 1

# rate matrix
Q := gtr(er,pi)

# in the lognormal clock, rates across branches are given by the exponential of the Brownian motion
# specifically, the rate along a branch is the mean of the exponential of the value of the Brownian motion at both ends

clockRate ~ exponential(0.1)

moves[index] <- mScale(clockRate, lambda=2.0, tune=true, weight=3.0)
index <- index + 1

# create the sequence evolution model
seq ~ substModel(tree=tau, Q=Q, branchRates=clockRate, nSites=nSites, type="DNA")

# condition on sequence alignment
seq.clamp(seqData)


######### 
# complete model and mcmc 
#########

"model"

# create the model
mymodel <- model(kappa)

# create the monitors

# screen monitor
monitors[1] <- screenmonitor(printgen=10, clockRate, correl, meanX)

# a trace monitor: like the screen monitor, but directly into file
monitors[2] <- filemonitor(filename="output/placdatestraitsclock.trace", printgen=10, separator = "	", clockRate, correl, meanX)

# file monitors for the correlation and partial correlation coefficients
monitors[3] <- filemonitor(filename="output/placdatestraitsclock.correl",printgen=10, separator = "	", correl, pCorrel)

# a file monitor just for the covariance matrix
monitors[4] <- filemonitor(filename="output/placdatestraitsclock.cov",printgen=10, separator = "	", Sigma)

# a file monitor for the evolution of traits along the tree (in newick format)
monitors[5] <- filemonitor(filename="output/placdatestraitsclock.traits",printgen=10, separator = "	", X)

# a model monitor
monitors[6] <- modelmonitor(filename="output/placdatestraitsclock.log",printgen=10, separator = "	")
 
mymcmc <- mcmc(mymodel, monitors, moves)

"burnin"
mymcmc.burnin(generations=100,tuningInterval=100)

mymcmc.run(100000)

# some post analysis here

