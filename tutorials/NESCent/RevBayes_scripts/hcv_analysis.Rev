##seed(1503, 21489)
printSeed()


D <- readCharacterData(file="data/HCV_data.nex")

## Starting tree from BEAST2 run
T <- readTrees("data/HCV_data_start.tre")[1]


n_taxa <- D.ntaxa()
n_sites <- D.nchar(1)
names <- D.names()


## Priors from Stadler et al. (2013)
origin ~ dnLnorm(1.0, 1.25)
origin

origin.setValue(treeHeight(T) * 1.2)
origin


## Setting the vector of parameter change times
n_intervals <- 10 
change_times <- n_intervals - 1

## This produces a vector of relative times from oldest -> youngest 
##### [ 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1 ]
for(i in 1:change_times){
	p_rel_times[i] <- abs(1.0 - (i * (1.0 / n_intervals))) 
##	p_abs_times[i] := origin * p_rel_times[i]
}

## The absolute times are a function of the origin time
## in principle, this initialization of the vector can go in the for-loop above,
## but there's an indexing issue (working on it)
p_abs_times[1] := origin * p_rel_times[1]
p_abs_times[2] := origin * p_rel_times[2]
p_abs_times[3] := origin * p_rel_times[3]
p_abs_times[4] := origin * p_rel_times[4]
p_abs_times[5] := origin * p_rel_times[5]
p_abs_times[6] := origin * p_rel_times[6]
p_abs_times[7] := origin * p_rel_times[7]
p_abs_times[8] := origin * p_rel_times[8]
p_abs_times[9] := origin * p_rel_times[9]


p_abs_times

s[1] <- 0.0 # samplingProportion (or psi)

## Creating vectors of m deterministic nodes for the changing parameters
## R0 and delta (delta = becomeUninfectiousRate in BEAST2)
for(i in 1:n_intervals){
	delta[i] ~ dnLnorm(1.0, 1.25) # delta : mu = delta - s*delta
	delta[i].setValue(1.0)
	R0[i] ~ dnLnorm(1.0, 1.25)
	R0[i].setValue(2.0)
##	lambda[i] := R0[i] * delta[i]
}
							
## lambda is a m-length vector of deterministic nodes
lambda[1] := R0[1] * delta[1]
lambda[2] := R0[2] * delta[2]
lambda[3] := R0[3] * delta[3]
lambda[4] := R0[4] * delta[4]
lambda[5] := R0[5] * delta[5]
lambda[6] := R0[6] * delta[6]
lambda[7] := R0[7] * delta[7]
lambda[8] := R0[8] * delta[8]
lambda[9] := R0[9] * delta[9]
lambda[10] := R0[10] * delta[10]

delta
R0
lambda

## These data are contemporary, so only 1 value for rho
rho[1] ~ dnBeta(1.0, 9999.0)
rho[1].setValue(1e-6)

## some deterministic nodes to monitor
rn_0 := R0[1]
uir_0 := delta[1]
l_0 := lambda[1]


# the BD-skyline model
tau ~ dnSkySerialBDP(origin=origin, lambda=lambda, lambdaTimes=p_abs_times,
					 mu=delta, muTimes=p_abs_times,
					 psi=s,
					 rho=rho,
					 timeSinceLastSample=0.0,
					 condition="nTaxa", names=names)

## The current model does not initialize properly
tau.setValue(T)


th := treeHeight(tau)

tau.lnProb

## setting the clock rate from "ad_e1_type4_rev.xml" BEAST2 file
clock_rate <- 0.79e-3

## GTR model
bf <- v(1,1,1,1)
e <- v(1,1,1,1,1,1)
sf ~ dirichlet(bf)
er ~ dirichlet(e)

sf

er

Q := gtr(er,sf)

## putting it all together
phySeq ~ phyloCTMC(tree=tau, Q=Q, branchRates=clock_rate, nSites=n_sites, type="DNA")
phySeq.clamp(D)


## specifying moves
mi <- 0
for(i in 1:n_intervals){
	moves[mi++] <- mvScale(delta[i], lambda=0.5, tune=false, weight=2.0)
	moves[mi++] <- mvScale(R0[i], lambda=0.5, tune=false, weight=2.0)
	moves[mi++] <- mvScale(delta[i], lambda=1.5, tune=false, weight=2.0)
	moves[mi++] <- mvScale(R0[i], lambda=1.5, tune=false, weight=2.0)
}
moves[mi++] <- mvScale(rho[1], lambda=0.01, tune=false, weight=3.0)
moves[mi++] <- mvOriginTimeSlide(origin, tau, delta=3.75, tune=true, weight=3.0)
moves[mi++] <- mvOriginTimeSlide(origin, tau, delta=10.0, tune=false, weight=1.0)
moves[mi++] <- mvOriginTimeSlide(origin, tau, delta=0.75, tune=false, weight=1.0)
moves[mi++] <- mvNodeTimeSlideUniform(tau, weight=30.0)
moves[mi++] <- mvRootTimeSlide(tau, delta=3.75, tune=true, weight=5.0)
moves[mi++] <- mvTreeScale(tau, 1.0, true, 3.0)
moves[mi++] <- mvNNI(tau, weight=8.0)
moves[mi++] <- mvNarrow(tau, weight=8.0)
moves[mi++] <- mvFNPR(tau, weight=8.0)
moves[mi++] <- mvSubtreeScale(tau, weight=5.0)
moves[mi++] <- mvSimplexElementScale(er, alpha=10.0, tune=true, weight=3.0)
moves[mi++] <- mvSimplexElementScale(sf, alpha=10.0, tune=true, weight=3.0)

mymodel <- model(er)

monitors[1] <- filemonitor(filename="hcv_skybdp.log", posterior=true, prior=true, 
							likelihood=true, printgen=10, separator = "	",
							origin, th, rho, R0, delta, lambda, er, sf, p_abs_times)
monitors[2] <- filemonitor(filename="hcv_skybdp.trees",printgen=10, separator = "	", tau)
monitors[3] <- screenmonitor(printgen=10, origin, rho, th, rn_0, uir_0)

mymcmc <- mcmc(mymodel, monitors, moves)

##mymcmc.burnin(generations=1000,tuningInterval=100)
mymcmc.run(generations=40000)

##mymcmc.operatorSummary()

