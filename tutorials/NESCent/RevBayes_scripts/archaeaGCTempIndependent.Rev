#
# Tutorial -- the phylogenetic comparative method
# Correlation analysis: rates, GC content, dates and life-history traits in placental mammals
# Nicolas Lartillot -- July 2014
#

######### 
# data
#########

# read the quantitative trait data 
contData <- readCharacterData("data/archaeaTemp.nex")

# get some useful variables from the data
contTaxaCount <- contData.ntaxa()
nTraits <- contData.nchar()[1]

"number of traits to analyze"
nTraits
contData

# read the sequence data
# the readCharacter function returns a vector of matrices. We just take the first one
seqData <- readCharacterData("data/archaeaRNA.nex")

# get some useful variables from the data
taxaCount <- seqData.ntaxa()
names <- seqData.names()
nSites <- seqData.nchar()[1]
"number of sites of the alignment"
nSites

######### 
# tree  
#########

# create a tree whose tips match the taxon names given by the dataset
tau ~ uniformTimeTree( originTime = 1.0, taxonNames = names)

index <- 1

# moves on the tree: only relative dates
moves[index] <- mSubtreeScale(tau, weight=5.0)
index <- index + 1
moves[index] <- mNodeTimeSlideUniform(tau, weight=10.0)
index <- index + 1
moves[index] <- mNNI(tau, weight=5.0)
index <- index + 1
moves[index] <- mFNPR(tau, weight=5.0)
index <- index + 1

######### 
# traits
#########

# covariance matrix of dimension nTraits + 2
# first entry will be log of substitution rate
# then all other entries will stand for the life-history traits

# covariance matrix is inverse Wishart of parameters kappa * Identity and df = nTraits+3 degrees of freedom
# where kappa is itself a scaling factor

sigmarate ~ exponential(0.1)
#sigmagc ~ exponential(0.1)
sigmatemp ~ exponential(0.1)

# moves on kappa
moves[index] <- mScale(sigmarate, lambda=2.0, tune=true, weight=3.0)
index <- index + 1
#moves[index] <- mScale(sigmagc, lambda=2.0, tune=true, weight=3.0)
#index <- index + 1
moves[index] <- mScale(sigmatemp, lambda=2.0, tune=true, weight=3.0)
index <- index + 1

# multivariate Brownian process along the tree
lograte ~ brownian(tau,sigmarate)
#logitgc ~ brownian(tau,sigmagc)
temp ~ brownian(tau,sigmatemp)

moves[index] <- mvRealNodeValTreeSliding(process=lograte,lambda=10,tune=true,weight=100) 
index <- index + 1
moves[index] <- mvRealNodeValTreeTranslation(process=lograte,lambda=1,tune=true,weight=1) 
index <- index + 1
#moves[index] <- mvRealNodeValTreeSliding(process=logitgc,lambda=10,tune=true,weight=100) 
#index <- index + 1
#moves[index] <- mvRealNodeValTreeTranslation(process=logitgc,lambda=1,tune=true,weight=1) 
#index <- index + 1
moves[index] <- mvRealNodeValTreeSliding(process=temp,lambda=10,tune=true,weight=100) 
index <- index + 1
moves[index] <- mvRealNodeValTreeTranslation(process=temp,lambda=1,tune=true,weight=1) 
index <- index + 1

temp.clampAt(contData,1)

meantemp := temp.mean()
roottemp := temp.rootVal()

######### 
# substitution process
#########

# equilibrium frequencies 
bf <- v(1,1,1,1)
pi ~ dirichlet(bf)

# moves on pi
moves[index] <- mSimplexElementScale(pi, alpha=10.0, tune=true, weight=1.0)
index <- index + 1

# first component of the Brownian model gives the *log* of the substitution rate
branchrates := expbranchtree(tree=tau,process=lograte)

# second component of the Brownian model gives the *logit* of the equilibrium GC content
# thus GC = tanh(X_2(t)), where X is the Brownian motion
# tanh is the hyperbolic tangent: tanh(x) = exp(x) / (1 + exp(x))
#branchGC := tanhBranchTree(tree=tau,process=logitgc)

# the transition / transversion ratio
tstv ~ exponential(0.1)

# each branch has its own substitution matrix, which is a T92 matrix
# defined by a transition/transversion ratio and an equilibrium GC
# so, we use branchGC, which gives a GC for each branch
# we combine it with the global ts/tv ratio
#branchMatrices := t92GCBranchTree(tree=tau,branchGC=branchGC,tstv=tstv)

# exchangeabilities
e <- v(1,1,1,1,1,1)
er ~ dirichlet(e)

# rate matrix
Q := gtr(er,pi)

# create the sequence evolution model
seq ~ substModel(tree=tau, Q=Q, rootFrequencies=pi, branchRates=branchrates, nSites=nSites, type="DNA")
#seq ~ substModel(tree=tau, Q=branchMatrices, rootFrequencies=pi, branchRates=branchrates, nSites=nSites, type="DNA")

# condition on sequence alignment
seq.clamp(seqData)

# create model
mymodel <- model(sigmarate)

# screen monitor
monitors[1] <- screenmonitor(printgen=10, meantemp, roottemp)

# similar monitor, but directly into file
monitors[2] <- filemonitor(filename="output/archaeagctempindependent2.trace", printgen=100, separator = "	", meantemp, roottemp)

# a file monitor for the evolution of traits along the tree (in newick format)
monitors[3] <- filemonitor(filename="output/archaeagctempindependent2.temp",printgen=100, separator = "	", temp)

# a file monitor for the evolution of traits along the tree (in newick format)
monitors[4] <- filemonitor(filename="output/archaeagctempindependent2.trees",printgen=100, separator = "	", tau)

# a model monitor
monitors[5] <- modelmonitor(filename="output/archaeagctempindependent2.log",printgen=100, separator = "	")
 
mymcmc <- mcmc(mymodel, monitors, moves)

mymcmc.burnin(generations=100,tuningInterval=100)

mymcmc.run(1000000)


