################################################################################
#
# RevBayes Example: Phylogeny inference using a mixture model between two
#                   substitution models:
#                   a) the general time reversible substitution model
#                   b) Jukes-Canotr substitution model.
#
# 
# This file: Specifies the a mixture model between a JC and a GTR subtitution model
#            with uncorrelated, exponentially distributed branch lengths. 
#            The tree is unrooted.
#            Here, we run an MCMC on this model.
#
# authors: Sebastian Hoehna
#
################################################################################



#######################
# Reading in the Data #
#######################

### Read in sequence data for both genes

data_atpB <- readCharacterData("data/conifer_atpB.nex")
data_rbcL <- readCharacterData("data/conifer_rbcL.nex")

### Create concatenated data matrix
data <- data_atpB + data_rbcL

# Get some useful variables from the data. We need these later on.
n_species <- data.ntaxa()
n_sites <- data.nchar(1)
names <- data.names()
n_branches <- 2 * n_species - 3





#######################
# Substitution Models #
#######################

mi <- 0

#### specify the JC substitution model applied uniformly to all sites ###
Q_JC <- JC(4)

#### specify the GTR substitution model applied uniformly to all sites ###
er_prior <- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_prior)
moves[mi++] <- mvSimplexElementScale(er, alpha=10.0, tune=true, weight=3.0)


sf_prior <- v(1,1,1,1) 
sf ~ dnDirichlet(sf_prior)
moves[mi++] <- mvSimplexElementScale(sf, alpha=10.0, tune=true, weight=2.0)


#### create a deterministic variable for the rate matrix ####
Q_GTR := gtr(er,sf) 



subst_model_prior <- simplex(1,1)
indices <- v(1,2)
vals := v(Q_JC,Q_GTR)

#mixtureIndex ~ dnMixture( indices, subst_model_prior)
#Q := vals[mixtureIndex]
#
#moves[mi++] <- mvMixtureAllocation(mixtureIndex,weight=1.0)


Q ~ dnMixture( vals, subst_model_prior )

# get a deterministic node for the indicator variable
mixtureIndex := Q.getAllocationIndex()

moves[mi++] <- mvMixtureAllocation(Q,weight=1.0)




##############
# Tree model #
##############

#### Specify a uniform prior on the tree topology #### 
topology ~ uniformTopology(n_species, names)

# moves on the tree
moves[mi++] <- mvNNI(topology, weight=10.0)


#### Specify a prior and moves on the branch lengths #### 
# create a random variable for each branch length using a for loop
for (i in 1:n_branches) {
  # We use here the exponential distribution with rate 1.0 as the branch length prior
  br_lens[i] ~ dnExponential(1.0)
  
  # Add a move for the branch length. We just take a simple scaling move since the value is a positive real number.
  moves[mi++] <- mvScale(br_lens[i],lambda=1,tune=true,weight=1) 
}
# create a deterministic variable for monitoring purposes
tree_length := sum(br_lens)

# Build the tree by combining the topology with the branch length.
phylogeny := treeAssembly(topology, br_lens)





###################
# PhyloCTMC Model #
###################

# the sequence evolution model
phyloSeq ~ dnPhyloCTMC(tree=phylogeny, Q=Q, nSites=n_sites, type="DNA")

# attach the data
phyloSeq.clamp(data)




#############
# THE Model #
#############


mymodel <- model(sf)



monitors[1] <- mnModel(filename="output/substition_mixture.log",printgen=10, separator = "	")
monitors[2] <- mnFile(filename="output/substitution_mixture.trees",printgen=10, separator = "	", phylogeny)
monitors[3] <- mnScreen(printgen=10, tree_length, mixtureIndex)

mymodel <- model(Q)
 
mymcmc <- mcmc(mymodel, monitors, moves)

#mymcmc.burnin(generations=200,tuningInterval=100)
mymcmc.run(generations=300)


