################################################################################
#
# RevBayes Exercise: Calculating Marginal Liklihoods and Bayes Factors to test
#  data partitioning strategies
# 
# This file: Specifies the full model parameters and moves for a 2-gene
#        partition model
#
# authors: Tracy A. Heath, Michael Landis, and Sebastian Hoehna
#
################################################################################

# Read in sequence data for both genes using a vector #
filenames <- v("data/conifer_atpB.nex", "data/conifer_rbcL.nex")

# A variable for the number of partitions #
n_parts <- filenames.size()

for (i in 1:n_parts){
  data[i] <- readCharacterData(filenames[i])
}

# Get some useful variables from the data needed for specifying the model #
# this assumes that both alignments have the same taxa #
n_species <- data[1].ntaxa()
names <- data[1].names()
n_branches <- 2 * n_species - 3

#####################################
#   Substitution Model: GTR+G * 2   #
#   looping over partitions         #
#####################################
mi <- 0 # an iterator for the move vector
for (i in 1:n_parts){
  ## index i=1 : atpB gene ##
  ## index i=2 : rbcL gene ##
  
  # Exchangeability rates #
  er_prior[i] <- v(1,1,1,1,1,1)
  er[i] ~ dnDirichlet(er_prior[i])
  moves[mi++] <- mvSimplexElementScale(er[i], alpha=10, tune=true, weight=3) 

  # Stationary base frequencies #
  sf_prior[i] <- v(1,1,1,1)
  sf[i] ~ dnDirichlet(sf_prior[i])
  moves[mi++] <- mvSimplexElementScale(sf[i], alpha=10, tune=true, weight=2) 

  # Instantaneous rate matrix (deterministic) #
  Q[i] := fnGTR(er[i],sf[i]) 

  # Gamma-dist site rates #
  shape_prior[i] <- 0.05 
  shape[i] ~ dnExponential( shape_prior[i] )
  gamma_rates[i] := fnDiscretizeGamma( shape[i], shape[i], 4 )
  moves[mi++] <- mvScale(shape[i], lambda=0.8, tune=true, weight=3.0)
}

######################################
#   Tree topology & Branch lengths   #
#   shared for all sites             #
######################################
# Unrooted tree topology distribution #
topology ~ dnUniformTopology(n_species, names)

# Tree topology moves #
moves[mi++] <- mvNNI(topology, weight=10.0)
moves[mi++] <- mvSPR(topology, weight=5.0)

#### Specify a prior and moves on the branch lengths #### 
# Create a vector of branch-length variables using a for loop #
for (i in 1:n_branches) {
  br_lens[i] ~ dnExponential(10.0)
  moves[mi++] <- mvScale(br_lens[i],lambda=1,tune=true,weight=1) 
}

# A deterministic node for the tree length #
tree_length := sum(br_lens)

# Build the tree by combining the topology with the vector of branch lengths #
phylogeny := treeAssembly(topology, br_lens)


### Create the DAG for each partition using a loop ###
for (i in 1:n_parts){
  # The sequence evolution model links the tree and GTR+G parameter #
  phyloSeq[i] ~ dnPhyloCTMC(tree=phylogeny, Q=Q[i], siteRates=gamma_rates[i], nSites=data[i].nchar(1), type="DNA")

  # Attach the data #
  phyloSeq[i].clamp(data[i])
}

# Specify the full model by indicating a single node in the DAG #
mymodel <- model(topology)
