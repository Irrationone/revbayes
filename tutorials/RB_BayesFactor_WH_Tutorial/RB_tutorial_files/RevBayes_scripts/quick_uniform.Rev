#### MCMC #####
source("RevBayes_scripts/uniform_partition_model.Rev")

# Set up file and screen monitors #
monitors[1] <- mnModel(filename="output/conifer_uniform_quick.log",printgen=10)
monitors[2] <- mnFile(filename="output/conifer_uniform_quick.trees",printgen=10, phylogeny)
monitors[3] <- screenmonitor(printgen=10, separator = " | ", shape, tree_length)

# Instantiate the MCMC analysis #
mymcmc <- mcmc(mymodel, monitors, moves)

# Start the chain and burn-in for several generations #
#mymcmc.burnin(generations=1000,tuningInterval=100)

# Run the MCMC and sample states #
mymcmc.run(generations=10000)


## Summarize MCMC output (tree topology/branch lengths) ##
# Read in & summarize the sampled states #
treetrace <- readTreeTrace("output/conifer_uniform_quick.trees", treetype="non-clock")
treetrace.summarize()

# Write the maximum a posteriori tree to file #
mapTree(treetrace,"output/conifer_uniform_quick.tre")
clear()

#### Marginal Likelihood ####
source("RevBayes_scripts/uniform_partition_model.Rev")

### Compute power posterior distributions
pow_p <- powerPosterior(mymodel, moves, "output/pow_p_uniform_quick.out", cats=35) 
pow_p.burnin(generations=1000,tuningInterval=100)
pow_p.run(generations=500)  

### Use stepping-stone sampling to calculate marginal likelihoods
ss <- steppingStoneSampler(file="output/pow_p_uniform_quick.out", powerColumnName="power", likelihoodColumnName="likelihood")
ss.marginal() 

### Use path-sampling to calculate marginal likelihoods
ps <- pathSampler(file="output/pow_p_uniform_quick.out", powerColumnName="power", likelihoodColumnName="likelihood")
ps.marginal() 


q()
