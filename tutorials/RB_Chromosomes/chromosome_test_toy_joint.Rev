# by Will Freyman
#
# source("/Users/mucho/Documents/projects/revbayes/revbayes/tutorials/RB_Chromosomes/chromosome_test_toy_joint.Rev")
#

######################
# read in the data 
######################

# this is toy data in which there are clearly 2 polyploidization events and no other events
chromoData <- readChromosomes("data/matK_chromosomes_toy.tsv")

# get DNA sequences
matK_seq <- readCharacterData("data/matK_treebase_aligned.fas")

# read in the starting tree that is consistent with our outgroup constraints
# this is a ML tree, so should be a pretty good start for the MCMC
starting_tree <- readBranchLengthTrees("data/matK_tree_lengths.nwk")[1]

# Get some useful variables from the data. We need these later on.
n_species <- matK_seq.ntaxa()
n_sites <- matK_seq.nchar(1)
names <- matK_seq.names()
n_branches <- 2 * n_species - 3

# get ingroup and outgroup for constraints
ingroup <- ["Aristolochia_serpantaria","Aristolochia_arborea","Aristolochia_wardiana","Aristolochia_californica","Aristolochia_saccata","Aristolochia_mollisima","Aristolochia_tomentosa","Aristolochia_neolongifolia_SETS52","Aristolochia_neolongifolia_SETS96"]
i <- 1
for (j in 1:names.size()) {
    found <- false
    for (k in 1:ingroup.size()) {
        if (ingroup[k] == names[j]) {
            found <- true
            break
        }
        k++
    }
    if (!found) {
        outgroup[i] <- names[j]
        i++
    }
    j++
}
mi <- 0
clade_ingroup <- clade(ingroup)
clade_outgroup <- clade(outgroup)
constraints <- v(clade_ingroup, clade_outgroup)




##############
# Tree model #
##############

#### Specify a uniform prior on the tree topology ####
## we need to constrain the outgroup for ancestral chromosome reconstruction!!
topology ~ uniformTopology(n_species, names, constraints)

# use the starting tree consistent with constraints
topology.setValue(starting_tree.topology())

# moves on the tree
moves[mi++] <- mvNNI(topology)

#### Specify a prior and moves on the branch lengths ####
# create a random variable for each branch length using a for loop
for (i in 1:n_branches) {
    # We use here the exponential distribution with rate 1.0 as the branch length prior
    br_lens[i] ~ dnExponential(10.0)

    # Add a move for the branch length. We just take a simple scaling move since the value is a positive real number.
    moves[mi++] <- mvScale(br_lens[i])
}

TL := sum(br_lens)

# Build the tree by combining the topology with the branch length.
phylogeny := treeAssembly(topology, br_lens)




######################
# Substitution Model #
######################

#### specify the GTR substitution model applied uniformly to all sites ###
er_prior <- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_prior)
moves[mi++] <- mvSimplexElementScale(er)


pi_prior <- v(1,1,1,1)
pi ~ dnDirichlet(pi_prior)
moves[mi++] <- mvSimplexElementScale(pi)


#### create a deterministic variable for the rate matrix ####
Q := gtr(er,pi)




###################
# Sequence evolution continuous-time Markov chain (CTMC)
###################

# the sequence evolution model
seq ~ phyloCTMC(tree=phylogeny, Q=Q, branchRates=1.0, type="DNA")

# attach the sequence data
seq.clamp(matK_seq)




#######################
# Chromosome Model
#######################

# rate of chromosome gains
pr_lambda ~ unif(0.0, 10.0)
lambda ~ exponential(pr_lambda)
lambda.setValue(1.0)

# rate of chromosome losses
pr_delta ~ unif(0.0, 10.0)
delta ~ exponential(pr_delta)
delta.setValue(1.0)

# rate of polyploidization
pr_rho ~ unif(0.0, 10.0)
rho ~ exponential(pr_rho)
rho.setValue(1.0)

# max number of chromosomes
max_chromo <- 35

# create rate matrix
R := chromosomes(max_chromo, lambda, delta, rho)

# TODO: properly estimate root state!!!
# need to create a chromosomeRF (see pomoRF) function that takes the root state (uniform 1 to max_chromo) parameter
# and returns a simplex:
# here we set the root state to 4
root_frequencies := simplex(0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)

# set up moves
moves[mi++] <- mvScale(lambda, tune=true) 
moves[mi++] <- mvScale(delta, tune=true) 
moves[mi++] <- mvScale(rho, tune=true) 

moves[mi++] <- mvScale(pr_lambda, tune=true)
moves[mi++] <- mvScale(pr_delta, tune=true)
moves[mi++] <- mvScale(pr_rho, tune=true)




###############
# Chromosome continuous-time Markov chain (CTMC)
###############
chromo ~ phyloCTMC(Q=R, tree=phylogeny, rootFreq=root_frequencies,type="Chromosomes")

# clamp data
chromo.clamp(chromoData)




##################
# Finalize the integrated model and set up MCMC
##################

mymodel <- model(chromo)

# create the monitors
monitors[1] <- screenmonitor(printgen=10, lambda, delta, rho)
monitors[2] <- modelmonitor(filename="output/chromosome_test_toy_joint2.log", printgen=10, separator = "	")
monitors[3] <- filemonitor(filename="output/chromosome_test_toy_joint2.trees", printgen=10, separator = "   ", phylogeny)

# set up mcmc
mymcmc <- mcmc(mymodel, monitors, moves)
#mymcmc.burnin(generations=1000,tuningInterval=100)
mymcmc.run(10000)


# Now, we will analyze the tree output.
# Let us start by reading in the tree trace
#treetrace <- readTreeTrace("output/chromosome_test_toy_joint.trees", treetype="non-clock", separator="    ")
# and get the summary of the tree trace
#treetrace.summarize()

#mapTree(treetrace, "output/chromosome_test_toy_joint.tree")

