# by Will Freyman
#
# source("/Users/mucho/Documents/projects/revbayes/tutorials/RB_Chromosomes/chromosome_test_toy_joint.Rev")
#

# read the data 
# this is toy data in which there are clearly 2 polyploidization events and no other events
chromoData <- readChromosomes("data/matK_chromosomes_toy.tsv")

# get DNA sequences
matK_seq <- readCharacterData("data/matK_treebase_aligned.fas")

# Get some useful variables from the data. We need these later on.
n_species <- matK_seq.ntaxa()
n_sites <- matK_seq.nchar(1)
names <- matK_seq.names()
n_branches <- 2 * n_species - 3

mi <- 0





######################
# Substitution Model #
######################

#### specify the GTR substitution model applied uniformly to all sites ###
er_prior <- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_prior)
moves[mi++] <- mvSimplexElementScale(er)


pi_prior <- v(1,1,1,1)
pi ~ dnDirichlet(pi_prior)
moves[mi++] <- mvSimplexElementScale(pi)


#### create a deterministic variable for the rate matrix ####
Q := gtr(er,pi)





##############
# Tree model #
##############

#### Specify a uniform prior on the tree topology ####
## TODO: add constraints to uniformTopology, see dnBDP() in m_BDP_bears.Rev
## we need to constrain the outgroup for ancestral chromosome reconstruction!!
topology ~ uniformTopology(n_species, names)

# speed this up by using a ML starting tree
#treeArray <- readTrees("data/matK_tree_lengths.nwk")
#psi <- treeArray[1]
#topology.setValue(psi)
# how do i get topology from timetree??


# moves on the tree
moves[mi++] <- mvNNI(topology)


#### Specify a prior and moves on the branch lengths ####
# create a random variable for each branch length using a for loop
for (i in 1:n_branches) {
    # We use here the exponential distribution with rate 1.0 as the branch length prior
    br_lens[i] ~ dnExponential(10.0)

    # Add a move for the branch length. We just take a simple scaling move since the value is a positive real number.
    moves[mi++] <- mvScale(br_lens[i])
}

TL := sum(br_lens)

# Build the tree by combining the topology with the branch length.
phylogeny := treeAssembly(topology, br_lens, constraints=constraints)


###################
# create the plate for the substitution model
###################


# the sequence evolution model
seq ~ phyloCTMC(tree=phylogeny, Q=Q, branchRates=1.0, type="DNA")

# attach the data
seq.clamp(matK_seq)



#######################
# Chromosome Model
#######################


# rate of chromosome gains
pr_lambda ~ unif(0.0, 10.0)
lambda ~ exponential(pr_lambda)
lambda.setValue(1.0)

# rate of chromosome losses
pr_delta ~ unif(0.0, 10.0)
delta ~ exponential(pr_delta)
delta.setValue(1.0)

# rate of polyploidization
pr_rho ~ unif(0.0, 10.0)
rho ~ exponential(pr_rho)
rho.setValue(1.0)

# max number of chromosomes
max_chromo <- 35

# create rate matrix
R := chromosomes(max_chromo, lambda, delta, rho)

#########
## TODO: properly estimate root state!!!
#########

## need to create a chromosomeRF (see pomoRF) function that takes the root state (uniform 1 to max_chromo) parameter
## and returns a simplex:
## here we set the root state to 4
root_frequencies := simplex(0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)

##############
# set up moves
#############
moves[mi++] <- mvScale(lambda, tune=true) 
moves[mi++] <- mvScale(delta, tune=true) 
moves[mi++] <- mvScale(rho, tune=true) 

moves[mi++] <- mvScale(pr_lambda, tune=true)
moves[mi++] <- mvScale(pr_delta, tune=true)
moves[mi++] <- mvScale(pr_rho, tune=true)


###############
# create the plate for the chromosome model
###############
chromo ~ phyloCTMC(Q=R, tree=phylogeny, rootFreq=root_frequencies,type="Chromosomes")

# clamp data
chromo.clamp(chromoData)

mymodel <- model(chromo)

# create the monitors
monitors[1] <- screenmonitor(printgen=10, lambda, delta, rho)
monitors[2] <- modelmonitor(filename="output/chromosome_test_toy_joint.log", printgen=10, separator = "	")
monitors[3] <- filemonitor(filename="output/chromosome_test_toy_joint.trees", printgen=10, separator = "   ", phylogeny)

# set up mcmc
mymcmc <- mcmc(mymodel, monitors, moves)
#mymcmc.burnin(generations=1000,tuningInterval=100)
mymcmc.run(10000)


# Now, we will analyze the tree output.
# Let us start by reading in the tree trace
treetrace <- readTreeTrace("output/chromosome_test_toy_joint.trees", treetype="non-clock")
# and get the summary of the tree trace
treetrace.summarize()

mapTree(treetrace, "output/chromosome_test_toy_joint.tree")

