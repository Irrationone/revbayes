/* * DistNormal.cpp * *  Created on: 25 aug 2009 *      Author: Sebastian */#include <cmath>#include "DistUniform.h"#include "datatypes/RbDataType.h"#include "datatypes/primary/RbDouble.h"#include "RbMath.h"#include "RbStatistics.h"#include "RbNames.h"DistUniform::DistUniform(DAGNode* l, DAGNode* u, DAGNode* x) {	lower = l;	upper = u;	obs   = x;	returnType = RbNames::Double::name;}DistUniform::DistUniform(DistUniform& d) {	lower = d.lower;	upper = d.upper;	obs   = d.obs;	returnType = d.returnType;}DistUniform::~DistUniform() {	// TODO Auto-generated destructor stub}/** * @brief Copy this object * * This is a call of the copy constructor used from the base class * * @return     return a deep copy of the object * */RbObject* DistUniform::clone(void) {	return new DistUniform(*this);}/*! * This function calculates the probability density * for a normally-distributed random variable. * * \brief Normal probability density. * \param mu is the mean parameter of the normal. * \param sigma is the variance parameter of the normal. * \param x is the normal random variable. * \return Returns the probability density. * \throws Does not throw an error. */double DistUniform::pdf(void) {	// first some argument checking	assert(typeid(*variable) == typeid(RbDouble));	double pdf = RbStatistics::Uniform::pdf(*lower, *upper);	return pdf;}/*! * This function calculates the natural log of the probability density * for a normally-distributed random variable. * * \brief Natural log of normal probability density. * \param mu is the mean parameter of the normal. * \param sigma is the variance parameter of the normal. * \param x is the normal random variable. * \return Returns the natural log of the probability density. * \throws Does not throw an error. */double DistUniform::lnPdf() {	// first some argument checking	assert(typeid(*variable) == typeid(RbDouble));	return RbStatistics::Normal::lnPdf(*lower,*upper,*obs);}RbObject* DistUniform::clone(void) const {	RbObject* x = (RbObject*)(new DistUniform(*this));	return x;}bool DistUniform::equals(const RbObject* o) const {	return false;}const StringVector& DistUniform::getClass(void) const {}bool DistUniform::isType(const std::string t) const {}void DistUniform::print(std::ostream& o) const {	o << "Uniform Distrbibution" << std::endl;}void DistUniform::printValue(std::ostream& o) const {	o << "Uniform Distribution with some value that we won't give" << std::endl;}std::string DistUniform::toString(void) const {	return "Uniform Distribution(" + obs->toString() + "|" + lower->toString() + "," + upper->toString() + ")";}RbObject& DistUniform::operator=(const RbObject& o) {    try {        // Use built-in fast down-casting first        const DistUniform& x = dynamic_cast<const DistUniform&> (obj);        DistUniform& y = (*this);        y = x;        return y;    } catch (std::bad_cast & bce) {        try {            // Try converting the value to an argumentRule            const DistUniform& x = dynamic_cast<const DistUniform&> (*(obj.convertTo(RbNames::Uniform::name)));            DistUniform& y = (*this);            y = x;            return y;        } catch (std::bad_cast & bce) {            RbException e("Not supported assignment of " + obj.getClass()[0] + " to " + RbNames::Uniform::name);            throw e;        }    }    // dummy return    return (*this);}DistUniform& DistUniform::operator=(const DistUniform& obj) {    *lower = *(obj.lower);    *upper = *(obj.upper);    *obs   = *(obj.obs);        return (*this);}